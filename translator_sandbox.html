<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Translator Sandbox</title>
</head>
<body>
<script>
// This sandboxed page can use eval/Function constructor to run legacy Zotero translators

// Forward console messages to the parent window so logs are visible
// in the extension popup (useful when DevTools for the iframe is not open).
(function(){
  try {
    const levels = ['log','info','warn','error','debug'];
    levels.forEach(level => {
      const orig = console[level].bind(console);
      console[level] = function(...args) {
        try {
          const serial = args.map(a => {
            try { return (typeof a === 'object') ? JSON.stringify(a) : String(a); } catch(e) { return String(a); }
          });
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({ type: 'SANDBOX_CONSOLE', level, args: serial }, '*');
          }
        } catch (e) {}
        try { orig(...args); } catch(e) {}
      };
    });
  } catch (e) {}
})();

// Dump all incoming postMessage events for debugging
window.addEventListener('message', (ev) => {
  try {
    console.log('[Sandbox][MSG]', ev.data, 'origin:', ev.origin);
  } catch (e) {}
  try {
    // Send an explicit acknowledgement of incoming messages back to the parent
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'SANDBOX_INCOMING', incoming: ev.data, origin: ev.origin }, '*');
    }
  } catch (e) {}
});
window.addEventListener('message', async (event) => {
  console.log('[Sandbox] Received message:', event.data.type);
  const { id, type, payload } = event.data;
  
  if (type === 'RUN_TRANSLATOR') {
    console.log('[Sandbox] Running translator, id:', id);
    try {
      const { translatorCode, htmlString, url } = payload;
      
      // Parse the HTML
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, 'text/html');
      
      // Track pending async operations
      let pendingAsyncOps = 0;
      
      // Create ZU helper
      const ZU = {
        xpath: (d, xp) => {
          const resolver = doc.createNSResolver(doc.documentElement || doc);
          const result = doc.evaluate(xp, d || doc, resolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
          const out = [];
          for (let i = 0; i < result.snapshotLength; i++) out.push(result.snapshotItem(i));
          return out;
        },
        xpathText: (d, xp) => {
          try {
            const r = doc.evaluate(xp, d || doc, null, XPathResult.STRING_TYPE, null);
            return r.stringValue || '';
          } catch (e) { return ''; }
        },
        trimInternal: (s) => s ? s.replace(/\s+/g, ' ').trim() : s,
        text: (d, selector) => {
          const el = (d || doc).querySelector(selector);
          return el ? el.textContent.trim() : '';
        },
        requestDocument: async (url) => {
          const res = await fetch(url);
          const txt = await res.text();
          return new DOMParser().parseFromString(txt, 'text/html');
        },
        cleanISBN: (s) => {
          if (!s) return false;
          const digits = (s + '').replace(/[^0-9Xx]/g, '');
          return digits.length >= 10 ? digits : false;
        },
        cleanISSN: (s) => {
          if (!s) return false;
          const digits = (s + '').replace(/[^0-9Xx]/g, '');
          return digits.length === 8 ? digits : false;
        },
        doGet: async (url, callback, responseCharset, cookieSandbox) => {
          // Legacy async GET request with callback - track as pending operation
          pendingAsyncOps++;
          try {
            const absolute = new URL(url, payload.url).href;
            const text = await requestText(absolute);
            const responseDoc = new DOMParser().parseFromString(text, 'text/html');
            if (callback) callback(text, responseDoc, url);
          } catch (e) {
            console.error('ZU.doGet failed:', e);
            if (callback) callback(null, null, url);
          } finally {
            pendingAsyncOps--;
          }
        }
      };
      
      // Create Zotero shim
      const Zotero = {
        _lastItem: null,
        debug: () => {},
        loadTranslator: (type) => {
          if (type === 'import') {
            let storedString = null;
            let itemHandler = null;
            return {
              setTranslator: (id) => {},
              setString: (s) => { storedString = s; },
              setHandler: (name, handler) => { if (name === 'itemDone') itemHandler = handler; },
              translate: async () => {
                if (!itemHandler) return;
                try {
                  const item = {
                    creators: [],
                    title: storedString || '',
                    DOI: '',
                    journal: '',
                    volume: '',
                    issue: '',
                    pages: '',
                    year: '',
                    abstractNote: '',
                    url: '',
                    attachments: [],
                    notes: [],
                    tags: [],
                    complete: function() {
                      Zotero._lastItem = this;
                    }
                  };
                  itemHandler(null, item);
                  await new Promise(resolve => setTimeout(resolve, 100));
                } catch (e) {
                  console.warn('itemDone error', e);
                }
              }
            };
          }
          return null;
        }
      };
      
      const Z = { debug: () => {}, monitorDOMChanges: () => {}, getHiddenPref: () => false };
      
      // Make location available globally for translator callbacks
      window.location = { href: url };
      
      const attr = (d, selector, name) => {
        try {
          const el = (d || doc).querySelector(selector);
          return el ? el.getAttribute(name) : '';
        } catch (e) { return ''; }
      };
      
      const text = (d, selector) => ZU.text(d, selector);
      
      const requestText = async (u, opts) => {
        const absolute = new URL(u, url).href;
        
        console.log('[Sandbox] requestText called, url:', absolute);
        
        // Sandbox can't make cross-origin requests - ask parent to do it
        return new Promise((resolve, reject) => {
          const fetchId = Date.now() + Math.random();
          const timeout = setTimeout(() => {
            console.error('[Sandbox] Fetch timeout for:', absolute);
            reject(new Error('Fetch timeout'));
          }, 30000);
          
          const handler = (event) => {
            if (event.data.type === 'FETCH_RESPONSE' && event.data.fetchId === fetchId) {
              console.log('[Sandbox] Received FETCH_RESPONSE, has error:', !!event.data.error, 'has text:', !!event.data.text);
              clearTimeout(timeout);
              window.removeEventListener('message', handler);
              
              if (event.data.error) {
                reject(new Error(event.data.error));
              } else {
                resolve(event.data.text);
              }
            }
          };
          
          window.addEventListener('message', handler);
          console.log('[Sandbox] Posting FETCH_REQUEST to parent, fetchId:', fetchId);
          window.parent.postMessage({
            type: 'FETCH_REQUEST',
            fetchId,
            url: absolute,
            opts
          }, '*');
        });
      };
      
      const requestDocument = async (u, opts) => {
        const txt = await requestText(u, opts);
        return new DOMParser().parseFromString(txt, 'text/html');
      };
      
      ZU.requestDocument = requestDocument;
      
      // Evaluate translator code
      const wrapper = new Function('Zotero', 'ZU', 'Z', 'doc', 'window', 'location', 'attr', 'text', 'requestText', 'requestDocument',
        `${translatorCode}; return { detectWeb: typeof detectWeb !== 'undefined' ? detectWeb : null, doWeb: typeof doWeb !== 'undefined' ? doWeb : null };`
      );
      
      const exports = wrapper(Zotero, ZU, Z, doc, window, window.location, attr, text, requestText, requestDocument);
      
      if (!exports || typeof exports.detectWeb !== 'function') {
        throw new Error('Translator missing detectWeb');
      }
      
      const kind = exports.detectWeb(doc, url);
      
      if (kind === 'multiple') {
        throw new Error('Multiple items not supported');
      }
      
      if (typeof exports.doWeb !== 'function') {
        throw new Error('Translator missing doWeb');
      }
      
      // Run the translator
      await exports.doWeb(doc, url);
      
      console.log('[Sandbox] doWeb completed, pending ops:', pendingAsyncOps);
      
      // Wait for pending async operations to complete
      const maxWait = 10000; // 10 seconds max
      const startWait = Date.now();
      while (pendingAsyncOps > 0 && (Date.now() - startWait) < maxWait) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      if (pendingAsyncOps > 0) {
        console.warn(`Translator completed with ${pendingAsyncOps} pending async operations`);
      }
      
      console.log('[Sandbox] After wait, checking _lastItem:', Zotero._lastItem);
      
      // Extract result
      const produced = Zotero._lastItem;
      
      let bibtex = '';
      if (produced) {
        console.log('[Sandbox] Produced item:', produced);
        // Check if title contains RIS data (translator stored RIS in the item)
        if (produced.title && /^TY\s+-\s+/m.test(produced.title)) {
          // Return RIS to parent for proper parsing
          window.parent.postMessage({ 
            id, 
            type: 'RESULT', 
            payload: { ris: produced.title, needsRisParsing: true }
          }, '*');
          return;
        }
        
        const authors = (produced.creators || [])
          .filter(c => c.creatorType === 'author' || !c.creatorType)
          .map(c => {
            if (c.lastName && c.firstName) return `${c.lastName}, ${c.firstName}`;
            if (c.lastName) return c.lastName;
            return (c.firstName || '').trim();
          });
        
        const fields = [];
        if (authors.length) fields.push(`  author = {${authors.join(' and ')}}`);
        if (produced.title) fields.push(`  title = {${produced.title}}`);
        if (produced.journal) fields.push(`  journal = {${produced.journal}}`);
        if (produced.year) fields.push(`  year = {${produced.year}}`);
        if (produced.volume) fields.push(`  volume = {${produced.volume}}`);
        if (produced.issue) fields.push(`  number = {${produced.issue}}`);
        if (produced.pages) fields.push(`  pages = {${produced.pages}}`);
        if (produced.DOI) fields.push(`  doi = {${produced.DOI}}`);
        if (produced.abstractNote) fields.push(`  abstract = {${produced.abstractNote}}`);
        
        bibtex = `@article{item${Date.now()},\n${fields.join(',\n')}\n}`;
      } else {
        console.warn('[Sandbox] No item produced by translator');
      }
      
      console.log('[Sandbox] Sending result, bibtex length:', bibtex.length);
      window.parent.postMessage({ id, type: 'RESULT', payload: { bibtex } }, '*');
    } catch (error) {
      window.parent.postMessage({ 
        id, 
        type: 'ERROR', 
        payload: { message: error.message || String(error) }
      }, '*');
    }
  }
});

// Signal ready
if (window.parent !== window) {
  window.parent.postMessage({ type: 'SANDBOX_READY' }, '*');
}
</script>
</body>
</html>
